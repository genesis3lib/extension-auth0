"""
Auth0 User Sync Middleware for Django

Syncs Auth0 authenticated users to local database after JWT validation.
Implements the same logic as Spring Boot's Auth0UserSyncFilter.

If email is missing from JWT, falls back to Auth0 userinfo endpoint.
"""

import os
import logging
import fnmatch
import requests
from django.conf import settings
from django.http import JsonResponse
from app_rbac.models import User, UserRole


logger = logging.getLogger(__name__)


class Auth0UserSyncMiddleware:
    """
    Middleware that syncs Auth0 users to the local database.

    Flow:
    1. Runs after JWT authentication (authentication.py)
    2. Checks if request has authenticated user (from JWT)
    3. Extracts user information from JWT payload
    4. Upserts user to database with role assignment
    5. Returns HTTP 500 if sync fails (fail fast)

    Environment variables for admin role assignment:
    - APP_USERS_ROOT: Single root user email (gets ROOT, ADMIN, USER roles)
    - APP_USERS_ADMINS: Comma-separated admin emails (get ADMIN, USER roles)
    """

    def __init__(self, get_response):
        self.get_response = get_response
        self.root_user = os.environ.get('APP_USERS_ROOT', '').strip()
        admins_str = os.environ.get('APP_USERS_ADMINS', '').strip()
        self.admin_users = [email.strip() for email in admins_str.split(',') if email.strip()]

    def __call__(self, request):
        # Skip public endpoints defined in settings.PUBLIC_URIS
        if self._is_public_path(request.path):
            return self.get_response(request)

        # Only sync if user is authenticated via Auth0
        if hasattr(request, 'user') and hasattr(request.user, 'payload'):
            try:
                self._sync_user_to_database(request.user)
            except Exception as e:
                logger.error(f'Failed to sync Auth0 user to database. Failing request: {str(e)}', exc_info=True)
                return JsonResponse(
                    {
                        'error': 'User synchronization failed',
                        'message': str(e)
                    },
                    status=500
                )

        return self.get_response(request)

    def _is_public_path(self, path):
        """
        Check if the given path matches any public URI pattern.
        Reads from settings.PUBLIC_URIS (list of URI patterns).
        """
        public_uris = getattr(settings, 'PUBLIC_URIS', [
            '/',
            '/api/v1/public/*',
            '/health',
            '/admin/*',
            '/static/*',
            '/media/*',
        ])

        for pattern in public_uris:
            # Convert pattern to fnmatch-compatible (simple wildcard matching)
            if fnmatch.fnmatch(path, pattern):
                return True
            # Also check exact match
            if path == pattern:
                return True

        return False

    def _sync_user_to_database(self, auth0_user):
        """
        Synchronize Auth0 user to local database with role assignment.

        Args:
            auth0_user: Auth0User object from authentication.py with payload
        """
        payload = auth0_user.payload
        access_token = getattr(auth0_user, 'token', None)

        # Extract user information from JWT
        email = payload.get('email')
        auth0_id = payload.get('sub')  # Format: "auth0|123456" or similar
        first_name = payload.get('given_name')
        last_name = payload.get('family_name')
        picture = payload.get('picture')

        # Fallback to Auth0 userinfo endpoint if email is missing from JWT
        if not email and access_token:
            logger.warning('Email claim missing from JWT token, falling back to Auth0 userinfo endpoint')
            userinfo = self._fetch_userinfo_from_auth0(access_token)
            email = userinfo.get('email')
            if not first_name:
                first_name = userinfo.get('given_name')
            if not last_name:
                last_name = userinfo.get('family_name')
            if not picture:
                picture = userinfo.get('picture')

        if not email:
            raise ValueError('Email not available from JWT claims or Auth0 userinfo endpoint')

        # Extract tenant ID from custom claim if configured
        {{#tenantIdClaimKey}}
        tenant_claim_key = getattr(settings, 'AUTH0_TENANT_CLAIM_KEY', '{{tenantIdClaimKey}}')
        tenant_id = payload.get(tenant_claim_key) if tenant_claim_key else None
        {{/tenantIdClaimKey}}
        {{^tenantIdClaimKey}}
        tenant_id = None
        {{/tenantIdClaimKey}}

        logger.debug(f'Syncing Auth0 user to database: email={email}, auth0_id={auth0_id}, tenant_id={tenant_id}')

        # Determine roles based on email
        roles = [UserRole.USER]
        if self.root_user and self.root_user.lower() == email.lower():
            logger.warning(f'Creating root user: {email}')
            roles = [UserRole.ROOT, UserRole.ADMIN, UserRole.USER]
        elif any(admin.lower() == email.lower() for admin in self.admin_users):
            logger.warning(f'Creating admin user: {email}')
            roles = [UserRole.ADMIN, UserRole.USER]

        # Upsert user to database
        user, created = User.objects.update_or_create(
            external_auth_provider='auth0',
            external_auth_id=auth0_id,
            defaults={
                'tenant_id': tenant_id,
                'username': email,  # Username same as email
                'email': email,
                'first_name': first_name,
                'last_name': last_name,
                'picture': picture,
                'enabled': True,
                'roles': roles,
                'deleted': False,
            }
        )

        action = 'Created' if created else 'Updated'
        logger.info(f'{action} user: {email} with roles: {roles}')

    def _fetch_userinfo_from_auth0(self, access_token):
        """
        Fetches user info from Auth0 userinfo endpoint using the access token.
        This is used as a fallback when email claim is not present in the JWT.

        Args:
            access_token: The user's access token

        Returns:
            dict: User info containing email, given_name, family_name, picture
        """
        auth0_domain = getattr(settings, 'AUTH0_DOMAIN', '')
        if not auth0_domain:
            raise ValueError('AUTH0_DOMAIN not configured in settings')

        userinfo_url = f'https://{auth0_domain}/userinfo'
        logger.debug(f'Fetching user info from Auth0: {userinfo_url}')

        try:
            response = requests.get(
                userinfo_url,
                headers={'Authorization': f'Bearer {access_token}'},
                timeout=10
            )
            response.raise_for_status()
            userinfo = response.json()
            logger.debug(f'Successfully fetched user info from Auth0: email={userinfo.get("email")}')
            return userinfo
        except requests.RequestException as e:
            logger.error(f'Failed to fetch user info from Auth0 userinfo endpoint: {str(e)}')
            raise RuntimeError(f'Failed to fetch user info from Auth0: {str(e)}')
